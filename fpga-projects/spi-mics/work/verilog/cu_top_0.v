/*
   This file was generated automatically by Alchitry Labs version 1.2.7.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module cu_top_0 (
    input clk,
    input rst_n,
    output reg [7:0] led,
    output reg usb_tx,
    input inc_btn_raw,
    input [2:0] adc,
    output reg adc_chip_select,
    output reg adc_clock,
    output reg adc_data_out
  );
  
  
  
  reg rst;
  
  reg fifo_write_flag;
  
  reg [23:0] fifo_data;
  
  reg fifo_read_flag;
  
  wire [1-1:0] M_reset_cond_out;
  reg [1-1:0] M_reset_cond_in;
  reset_conditioner_1 reset_cond (
    .clk(clk),
    .in(M_reset_cond_in),
    .out(M_reset_cond_out)
  );
  wire [1-1:0] M_btn_cond_out;
  button_conditioner_2 btn_cond (
    .clk(clk),
    .in(inc_btn_raw),
    .out(M_btn_cond_out)
  );
  wire [1-1:0] M_button_press_dtct_out;
  edge_detector_3 button_press_dtct (
    .clk(clk),
    .in(M_btn_cond_out),
    .out(M_button_press_dtct_out)
  );
  wire [1-1:0] M_uart_tx_tx;
  wire [1-1:0] M_uart_tx_busy;
  reg [1-1:0] M_uart_tx_block;
  reg [8-1:0] M_uart_tx_data;
  reg [1-1:0] M_uart_tx_new_data;
  uart_tx_4 uart_tx (
    .clk(clk),
    .rst(rst),
    .block(M_uart_tx_block),
    .data(M_uart_tx_data),
    .new_data(M_uart_tx_new_data),
    .tx(M_uart_tx_tx),
    .busy(M_uart_tx_busy)
  );
  reg [7:0] M_increment_counter_d, M_increment_counter_q = 1'h0;
  wire [1-1:0] M_slow_clock_out;
  clock_divider_5 slow_clock (
    .clk(clk),
    .rst(rst),
    .out(M_slow_clock_out)
  );
  wire [1-1:0] M_slower_clock_out;
  clock_divider_6 slower_clock (
    .clk(clk),
    .rst(rst),
    .out(M_slower_clock_out)
  );
  reg M_read_fifo_requested_d, M_read_fifo_requested_q = 1'h0;
  reg [23:0] M_samples_buffer_d, M_samples_buffer_q = 1'h0;
  reg [2:0] M_samples_to_send_d, M_samples_to_send_q = 1'h0;
  reg [7:0] M_samples_until_sync_byte_d, M_samples_until_sync_byte_q = 1'h0;
  reg M_send_sync_byte_d, M_send_sync_byte_q = 1'h0;
  wire [1-1:0] M_sample_fifo_full;
  wire [24-1:0] M_sample_fifo_dout;
  wire [1-1:0] M_sample_fifo_empty;
  fifo_7 sample_fifo (
    .clk(clk),
    .rst(rst),
    .din(fifo_data),
    .wput(fifo_write_flag),
    .rget(fifo_read_flag),
    .full(M_sample_fifo_full),
    .dout(M_sample_fifo_dout),
    .empty(M_sample_fifo_empty)
  );
  wire [1-1:0] M_adcs_spi_dout;
  wire [1-1:0] M_adcs_chip_select;
  wire [1-1:0] M_adcs_spi_clock;
  wire [1-1:0] M_adcs_fifo_write_flag;
  wire [24-1:0] M_adcs_fifo_data;
  mcp3002array_8 adcs (
    .clk(clk),
    .rst(rst),
    .spi_din(adc),
    .fifo_full_flag(M_sample_fifo_full),
    .spi_dout(M_adcs_spi_dout),
    .chip_select(M_adcs_chip_select),
    .spi_clock(M_adcs_spi_clock),
    .fifo_write_flag(M_adcs_fifo_write_flag),
    .fifo_data(M_adcs_fifo_data)
  );
  
  always @* begin
    M_samples_buffer_d = M_samples_buffer_q;
    M_increment_counter_d = M_increment_counter_q;
    M_send_sync_byte_d = M_send_sync_byte_q;
    M_samples_until_sync_byte_d = M_samples_until_sync_byte_q;
    M_read_fifo_requested_d = M_read_fifo_requested_q;
    M_samples_to_send_d = M_samples_to_send_q;
    
    M_reset_cond_in = ~rst_n;
    rst = M_reset_cond_out;
    adc_chip_select = M_adcs_chip_select;
    fifo_write_flag = M_adcs_fifo_write_flag;
    fifo_data = M_adcs_fifo_data;
    fifo_read_flag = M_read_fifo_requested_q;
    adc_clock = 1'h0;
    adc_clock = M_adcs_spi_clock;
    adc_data_out = M_adcs_spi_dout;
    if (M_button_press_dtct_out) begin
      M_increment_counter_d = M_increment_counter_q + 1'h1;
    end
    led[0+0-:1] = M_slow_clock_out;
    led[1+0-:1] = M_slower_clock_out;
    led[7+0-:1] = 1'h0;
    usb_tx = M_uart_tx_tx;
    M_uart_tx_block = 1'h0;
    M_uart_tx_new_data = 1'h0;
    M_uart_tx_data = 8'hff;
    M_samples_until_sync_byte_d = M_samples_until_sync_byte_q;
    M_samples_to_send_d = M_samples_to_send_q;
    M_read_fifo_requested_d = 1'h0;
    M_send_sync_byte_d = M_send_sync_byte_q;
    if (M_read_fifo_requested_q == 1'h1) begin
      M_samples_buffer_d = M_sample_fifo_dout;
      M_samples_to_send_d = 2'h3;
      if (M_samples_until_sync_byte_q == 1'h0) begin
        M_samples_until_sync_byte_d = 6'h20;
        M_send_sync_byte_d = 1'h1;
      end else begin
        M_samples_until_sync_byte_d = M_samples_until_sync_byte_q - 1'h1;
      end
    end
    if (M_uart_tx_busy == 1'h0) begin
      if (M_send_sync_byte_q == 1'h1) begin
        M_uart_tx_new_data = 1'h1;
        M_uart_tx_data = 8'hff;
        M_send_sync_byte_d = 1'h0;
      end else begin
        if (M_samples_to_send_q > 1'h0) begin
          M_uart_tx_new_data = 1'h1;
          M_uart_tx_data = M_samples_buffer_q[0+7-:8];
          M_samples_buffer_d = M_samples_buffer_q >> 4'h8;
          M_samples_to_send_d = M_samples_to_send_q - 1'h1;
        end else begin
          if (M_read_fifo_requested_q == 1'h0 && M_samples_to_send_q == 1'h0 && M_sample_fifo_empty == 1'h0) begin
            M_read_fifo_requested_d = 1'h1;
          end
        end
      end
    end
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_increment_counter_q <= 1'h0;
      M_read_fifo_requested_q <= 1'h0;
      M_samples_buffer_q <= 1'h0;
      M_samples_to_send_q <= 1'h0;
      M_samples_until_sync_byte_q <= 1'h0;
      M_send_sync_byte_q <= 1'h0;
    end else begin
      M_increment_counter_q <= M_increment_counter_d;
      M_read_fifo_requested_q <= M_read_fifo_requested_d;
      M_samples_buffer_q <= M_samples_buffer_d;
      M_samples_to_send_q <= M_samples_to_send_d;
      M_samples_until_sync_byte_q <= M_samples_until_sync_byte_d;
      M_send_sync_byte_q <= M_send_sync_byte_d;
    end
  end
  
endmodule
